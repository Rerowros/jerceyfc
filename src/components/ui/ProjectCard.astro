---
// src/components/ui/ProjectCard.astro
import type { CollectionEntry } from 'astro:content';
import { Image } from 'astro:assets';
import { getProjectStyle } from '../../utils/projectStyles';
import { projectIcons } from '../../utils/icons';

interface Props {
  project: CollectionEntry<'projects'>;
  // ИСПРАВЛЕНИЕ: Добавляем index в пропсы (опционально), чтобы TS не ругался
  index?: number;
}

const { project, index = 99 } = Astro.props; // Значение по умолчанию 99, чтобы priority не срабатывал если индекс не передан
const { data, slug } = project;

const style = getProjectStyle(data.tags, data.type);
// @ts-ignore
const currentIcon = projectIcons[data.type] || projectIcons.web;
const coverImage = data.coverImage;
const hasImage = !!coverImage;
---

<a
  href={`/projects/${slug}`}
  class="project-card-tilt group relative flex h-full flex-col overflow-hidden rounded-3xl border border-[var(--color-border)] bg-[var(--color-card)]"
  style="transform-style: preserve-3d; will-change: transform; content-visibility: auto; contain-intrinsic-size: 1px 400px;"
>
  <!-- 1. ТЕКСТУРА ШУМА -->
  <div
    class="pointer-events-none absolute inset-0 z-0 opacity-[0.07] mix-blend-soft-light"
    style='background-image: url("data:image/svg+xml,%3Csvg viewBox=\"0 0 200 200\" xmlns=\"http://www.w3.org/2000/svg\"%3E%3Cfilter id=\"noiseFilter\"%3E%3CfeTurbulence type=\"fractalNoise\" baseFrequency=\"0.8\" numOctaves=\"3\" stitchTiles=\"stitch\"/%3E%3C/filter%3E%3Crect width=\"100%25\" height=\"100%25\" filter=\"url(%23noiseFilter)\"/%3E%3C/svg%3E"); transform: translateZ(0);'
  >
  </div>

  <!-- 2. ЭФФЕКТ БЛИКА -->
  <div
    class="card-glare pointer-events-none absolute -inset-[100%] z-50 opacity-0 transition-opacity duration-300 will-change-transform group-hover:opacity-100"
    style="background: radial-gradient(circle at center, rgba(255,255,255,0.15) 0%, transparent 60%); mix-blend-mode: overlay; transform: translateZ(1px);"
  >
  </div>

  <div
    class="mobile-shine pointer-events-none absolute inset-0 z-40 -translate-x-full skew-x-12 bg-gradient-to-r from-transparent via-white/10 to-transparent md:hidden"
  >
  </div>

  <!-- ВЕРХНЯЯ ЧАСТЬ -->
  <div
    class="relative z-10 h-56 w-full overflow-hidden border-b border-[var(--color-border)] bg-[var(--color-card)]"
    style="transform: translateZ(20px);"
  >
    {/* Статус Featured */}
    {
      data.featured && (
        <div class="absolute top-4 left-4 z-30">
          <span class="inline-flex items-center gap-1.5 rounded-full border border-amber-500/30 bg-black/40 px-2.5 py-1 text-[10px] font-bold tracking-wider text-amber-400 uppercase shadow-lg backdrop-blur-md">
            <span class="relative flex h-1.5 w-1.5">
              <span class="absolute inline-flex h-full w-full animate-ping rounded-full bg-amber-400 opacity-75" />
              <span class="relative inline-flex h-1.5 w-1.5 rounded-full bg-amber-500" />
            </span>
            Featured
          </span>
        </div>
      )
    }

    {
      hasImage && coverImage ? (
        <>
          <div class="absolute inset-0 z-10 bg-gradient-to-t from-[var(--color-card)] via-transparent to-transparent opacity-60" />
          <div class="absolute top-4 right-4 z-20 rounded-xl border border-white/10 bg-black/40 p-2 text-white/80 shadow-lg backdrop-blur-md">
            <svg
              class="h-4 w-4"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
              stroke-width="2"
              set:html={currentIcon}
            />
          </div>
          <Image
            src={coverImage}
            alt={data.title.en}
            width={600}
            height={400}
            format="webp"
            quality={80}
            priority={index < 3}
            class="h-full w-full object-cover transition-transform duration-700 group-hover:scale-105"
          />
        </>
      ) : (
        <div
          class={`absolute inset-0 h-full w-full bg-gradient-to-br ${style.gradient} animate-shimmer flex items-center justify-center overflow-hidden`}
        >
          <div class="bg-grid-pattern absolute inset-0 opacity-30 mix-blend-overlay" />

          {/* Водяной знак */}
          <div
            class="font-cinzel pointer-events-none absolute -right-4 -bottom-4 overflow-hidden text-8xl leading-none font-black tracking-tighter text-white opacity-[0.07] select-none"
            style="transform: translateZ(10px);"
          >
            {style.label}
          </div>

          {/* Иконка */}
          <div
            class={`relative z-10 ${style.iconColor} opacity-90 transition-transform duration-500 group-hover:scale-110 group-hover:-rotate-3 group-hover:drop-shadow-[0_0_20px_rgba(255,255,255,0.4)]`}
            style="transform: translateZ(40px);"
          >
            <svg
              class="h-16 w-16"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
              stroke-width="1.5"
              set:html={currentIcon}
            />
          </div>
        </div>
      )
    }
  </div>

  <!-- НИЖНЯЯ ЧАСТЬ -->
  <div
    class="relative z-10 flex flex-grow flex-col bg-[var(--color-card)] p-6"
    style="transform: translateZ(20px);"
  >
    <div class="mb-3">
      <h3
        class="font-cinzel line-clamp-1 text-lg leading-tight font-bold text-[var(--color-foreground)] transition-colors group-hover:text-[var(--color-primary)] md:text-xl"
      >
        <span class="lang-ru">{data.title.ru}</span>
        <span class="lang-en">{data.title.en}</span>
      </h3>
    </div>

    <p
      class="mb-6 line-clamp-2 flex-grow text-sm leading-relaxed text-[var(--color-muted-foreground)]"
    >
      <span class="lang-ru">{data.description.ru}</span>
      <span class="lang-en">{data.description.en}</span>
    </p>

    <div
      class="mt-auto flex items-center justify-between border-t border-[var(--color-border)]/50 pt-4"
    >
      <div class="flex items-center gap-2">
        {
          data.tags
            .slice(0, 2)
            .map((tag: string) => (
              <span class="rounded-md border border-[var(--color-border)] bg-[var(--color-foreground)]/5 px-2 py-1 text-[10px] font-bold tracking-wide text-[var(--color-muted-foreground)] uppercase">
                {tag}
              </span>
            ))
        }
        {
          data.tags.length > 2 && (
            <span class="text-[10px] text-[var(--color-muted-foreground)] opacity-60">
              +{data.tags.length - 2}
            </span>
          )
        }
      </div>

      <div
        class="flex h-8 w-8 items-center justify-center rounded-full border border-[var(--color-border)] text-[var(--color-muted-foreground)] transition-all duration-300 group-hover:border-[var(--color-primary)] group-hover:bg-[var(--color-primary)] group-hover:text-white"
      >
        <svg class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M5 12h14M12 5l7 7-7 7"></path>
        </svg>
      </div>
    </div>
  </div>
</a>

<script>
  function initTilt() {
    // 1. Быстрая проверка на мобильные
    if (window.matchMedia('(hover: none)').matches) return;

    // 2. ОТЛОЖЕННЫЙ ЗАПУСК: Ждем пока main thread освободится после навигации
    // Если requestIdleCallback не поддерживается (Safari), фоллбек на setTimeout
    const defer = window.requestIdleCallback || ((cb) => setTimeout(cb, 200));

    defer(() => {
      const cards = document.querySelectorAll('.project-card-tilt');

      // Если карточек нет или мы уже ушли со страницы пока ждали
      if (cards.length === 0) return;

      cards.forEach((card) => {
        // ... (Весь код логики state/animate оставляем без изменений) ...
        let state = {
          mouseX: 0,
          mouseY: 0,
          height: 0,
          width: 0,
          left: 0,
          top: 0,
          targetX: 0,
          targetY: 0,
          currentX: 0,
          currentY: 0,
          request: null as number | null,
          isHovering: false,
        };

        // @ts-ignore
        const glare = card.querySelector('.card-glare');

        const updateDimensions = () => {
          // @ts-ignore
          const rect = card.getBoundingClientRect();
          state.width = rect.width;
          state.height = rect.height;
          state.left = rect.left;
          state.top = rect.top;
        };

        const animate = () => {
          if (
            !state.isHovering &&
            Math.abs(state.currentX) < 0.1 &&
            Math.abs(state.currentY) < 0.1
          ) {
            // @ts-ignore
            card.style.transform = 'perspective(1000px) rotateX(0) rotateY(0) scale3d(1, 1, 1)';
            state.request = null;
            return;
          }

          if (state.isHovering) {
            const centerX = state.width / 2;
            const centerY = state.height / 2;
            const localX = state.mouseX - state.left;
            const localY = state.mouseY - state.top;

            state.targetX = ((localY - centerY) / centerY) * -8;
            state.targetY = ((localX - centerX) / centerX) * 8;
          } else {
            state.targetX = 0;
            state.targetY = 0;
          }

          state.currentX += (state.targetX - state.currentX) * 0.1;
          state.currentY += (state.targetY - state.currentY) * 0.1;

          // @ts-ignore
          card.style.transform = `perspective(1000px) rotateX(${state.currentX}deg) rotateY(${state.currentY}deg) scale3d(1.02, 1.02, 1.02)`;

          if (glare && state.isHovering) {
            // @ts-ignore
            const glareX = state.mouseX - state.left;
            // @ts-ignore
            const glareY = state.mouseY - state.top;
            // @ts-ignore
            glare.style.transform = `translate(${glareX}px, ${glareY}px) translate(-50%, -50%) translateZ(1px)`;
          }

          state.request = requestAnimationFrame(animate);
        };

        // @ts-ignore
        card.addEventListener('mouseenter', () => {
          state.isHovering = true;
          updateDimensions();
          // @ts-ignore
          card.style.transition = 'none';
          if (glare) {
            // @ts-ignore
            glare.style.transition = 'opacity 0.3s ease';
          }

          if (!state.request) {
            state.request = requestAnimationFrame(animate);
          }
        });

        // @ts-ignore
        card.addEventListener('mousemove', (e: MouseEvent) => {
          state.mouseX = e.clientX;
          state.mouseY = e.clientY;
        });

        // @ts-ignore
        card.addEventListener('mouseleave', () => {
          state.isHovering = false;
          // @ts-ignore
          card.style.transition = 'transform 0.6s cubic-bezier(0.23, 1, 0.32, 1)';
        });

        window.addEventListener('resize', updateDimensions);
      });
    });
  }

  document.addEventListener('astro:page-load', initTilt);
  document.addEventListener('DOMContentLoaded', initTilt);
</script>

<script>
  document.addEventListener('astro:page-load', () => {
    if (window.innerWidth < 768) {
      const cards = document.querySelectorAll('.project-card-tilt');

      const observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              const shine = entry.target.querySelector('.mobile-shine');
              if (shine) {
                shine.animate(
                  [
                    { transform: 'translateX(-100%) skewX(-15deg)' },
                    { transform: 'translateX(200%) skewX(-15deg)' },
                  ],
                  { duration: 1500, easing: 'ease-in-out' }
                );
              }
              observer.unobserve(entry.target);
            }
          });
        },
        { threshold: 0.3 }
      );

      cards.forEach((card) => observer.observe(card));
    }
  });
</script>
